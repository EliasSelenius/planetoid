

const Item_Count = 3;
enum Item_Type {
    Grenade;
    Drill;
    Bazooka;
}

string item_name(Item_Type it) switch (it) {
    case .Grenade:  return make_string("Grenade");
    case .Drill:    return make_string("Drill");
    case .Bazooka:  return make_string("Bazooka");

    default: return make_string("");
}

struct Inventory {
    uint32[Item_Count] items;
}

struct Rigidbody2D {
    vec2 vel;
    float32 ang_vel;
    float32 mass;
    float32 cof_s; // coefficient of static friction
    float32 cof_k; // coefficient of kinetic friction
    float32 cod;   // coefficient of drag
    float32 cor;   // coefficient of restitution
}

void apply_impulse(Rigidbody2D* rb, vec2 imp) rb.vel = rb.vel + imp / rb.mass;
void apply_impulse(Entity* en, vec2 imp) apply_impulse(*en.rb, imp);

const Drag_Coff_Of_Sphere = 0.47;

vec2 calc_dragforce(vec2 vel, float32 cod, fluid_density) {
    float32 dragforce_mag = 0.5 * fluid_density * cod * sqlength(vel);
    vec2    dragforce = neg(noz(vel)) * dragforce_mag;
    return dragforce;
}

enum Entity_Type {
    Other;
    Despawned;
    Ready_For_Reuse;
    Guy;
    Grenade;
}

struct Entity {
    Planet* planet;

    Entity_Type en_type;

    DrawBuffers db;
    Texture2D tex;

    Transform2D tr;
    Rigidbody2D rb;

    float32 life_time;
    float32 radius;
    bool grounded;
    vec2 normal;

    Inventory* inv;
    Item_Type selected_item;
}


bool is_inactive(Entity* en) return en.en_type == Entity_Type.Despawned or en.en_type == Entity_Type.Ready_For_Reuse;
void despawn(Entity* en) en.en_type = .Despawned;

struct Planet {
    VoxelGrid grid;
    Transform2D tr;

    float32 radius;
    float32 orbit_dist;
    float32 orbit_duration;
    float32 orbit_phase;
}


const entities_capacity = 256;
int32 entities_count = 0;
Entity* entities;
Entity* player;


const planets_count = 9;
Planet* planets;

Particle[..] particles = list_create(sizeof Particle);
struct Particle {
    Transform2D tr;
    float32 depth;

    vec2 vel;
    float32 ang_vel;

    float32 life_time;
}

Particle* spawn_particle(Particle p) {
    Particle* res = list_add(*particles, *p);
    return res;
}

Entity* spawn_entity(DrawBuffers db) {
    if entities_count >= entities_capacity {
        print("Failed to append entity. Max limit reached.\n");
        return null;
    }

    Entity* en = null;
    for 0 .. entities_count {
        let o = *entities[it];
        if o.en_type == Entity_Type.Ready_For_Reuse {
            en = o;
            break;
        }
    }

    if en == null  en = *entities[entities_count++];

    @en = {};
    en.tr.scale = 1;
    en.db = db;

    en.rb.mass = 1;
    en.rb.cof_k = 1;
    en.rb.cof_s = 1.2 * en.rb.cof_k;
    en.rb.cod = Drag_Coff_Of_Sphere;
    return en;
}

Entity* spawn_guy(vec2 pos) {
    let en = spawn_entity(db_quad);
    en.en_type = .Guy;
    en.tex = player_texture;
    en.tr.scale = (1.0 / en.tex.width);
    en.radius = 0.5;
    en.tr.pos = pos;
    en.rb.cof_k = 0.5;
    return en;
}

void cleanup_entity_pool() {
    for 0 .. entities_count {
        let en = *entities[it];
        if en.en_type == Entity_Type.Despawned {
            en.en_type = .Ready_For_Reuse;
        }
    }
}

Planet* get_planet_of_influence(vec2 pos) {
    Planet* res = null;
    float32 min_sq_dist = 99999999999;

    for 0 .. planets_count {
        Planet* planet = *planets[it];
        let radius = planet.radius * 2;
        let sq_dist = sqdist(planet.tr.pos, pos);
        if sq_dist < radius*radius {
            if sq_dist < min_sq_dist {
                res = planet;
                min_sq_dist = sq_dist;
            }
        }
    }

    return res;
}

void draw_trajectory(vec2 pos, vel, float32 mass, cod) {
    // let dt = deltatime();
    float32 dt = 1 / 60.0;

    for 0 .. 100 {
        pos = pos + vel*dt;

        let p = get_planet_of_influence(pos);
        if p {

            float32 fluid_density = 0.5;
            vec2 dragforce = calc_dragforce(vel, cod, fluid_density);
            vel = vel + (dragforce * dt) / mass;

            let down = noz(p.tr.pos - pos);
            vel = vel + down*9.8*dt;
        }

        draw_circle(pos, 0.05, vec4_one);
    }
}

void update_entity(Entity* en) {
    let dt = deltatime();
    en.tr.pos = en.tr.pos + en.rb.vel * dt;

    en.planet = get_planet_of_influence(en.tr.pos);

    bool collided = false;

    if en.planet {
        draw_circle(en.tr.pos, en.radius, make_vec(1,1,1, 0.3));

        float32 fluid_density = 0.5;
        vec2 dragforce = calc_dragforce(en.rb.vel, en.rb.cod, fluid_density);
        apply_impulse(en, dragforce * dt);



        en.normal = vec2_zero;
        Intersection2D inter = {};
        if circle_intersects(*en.planet.grid, en.planet.tr, en.tr.pos, en.radius, *inter) {
            en.normal = inter.surface_normal;
            collision_response(*en.tr, *en.rb, inter);
            collided = true;
        }



        vec2 diff = en.planet.tr.pos - en.tr.pos;
        let sq_dist = sqlength(diff);
        vec2 down = noz(diff);

        float32 area = Pi * en.planet.radius * en.planet.radius;
        float32 planet_mass = area; // assuming the same uniform mass-density on all planets.
        vec2 gravity = down * planet_mass / sq_dist;
        if sq_dist == 0.0 { gravity = vec2_zero; }
        // en.rb.vel = en.rb.vel + gravity*dt;
        en.rb.vel = en.rb.vel + down*9.8*dt;



        float32 floor2multiple(float32 x, n) return floorf(x/n) * n;

        // [ -Pi .. Pi ]
        let target_angle = vec2_to_angle(neg(down));
        // target_angle += floor2multiple(en.tr.rot, Tau);

        // en.tr.rot = fract((en.tr.rot + Pi) / Tau) * Tau - Pi; // normalizes angle to [-Pi, Pi] range


        en.tr.rot = exp_decay(en.tr.rot, target_angle, 3, dt);

        // float32 text_h = 0.05;
        // draw_text(make_vec(0, 0.02), text_h, to_string((en.tr.rot * rad2deg) as int32), White);
        // draw_text(make_vec(0, 0.02 - text_h), text_h, to_string((target_angle * rad2deg) as int32), White);
    }

    en.grounded = collided;

    switch (en.en_type) {
        case .Other: break;
        case .Despawned: break;
        case .Ready_For_Reuse: break;
        case .Guy: break;
        case .Grenade: {
            if en.life_time >= 4 {
                if en.planet {
                    remove_circle(*en.planet.grid, en.planet.tr, 2, en.tr.pos);
                }

                despawn(en);
            }
        } break;

        default: break;
    }

    en.life_time += dt;
}

void collision_response(Transform2D* tr, Rigidbody2D* rb, Intersection2D inter) {
    vec2 normal = inter.surface_normal;
    vec2 correction = normal * -inter.distance;
    tr.pos = tr.pos + correction;

    // float32 dist = -inter.distance;
    // float32 d = dot(normal, rb.vel);
    // if d < 0.0 {
    //     vec2 correction = rb.vel * dist / d;
    //     tr.pos = tr.pos + correction;
    // }

    rb.vel = calc_new_vel(rb.vel, normal, rb.mass, rb.cor, rb.cof_s, rb.cof_k);

    // // float32 bounce = 1;
    // // let ref = (reflect(rb.vel, normal) - rb.vel) * bounce;

    // let new_vel = rb.vel + normal * -dot(rb.vel, normal); // cancel velocity in direction of surface

    // let normal_force = -dot(rb.vel, normal); // * rb.mass;
    // let fric_dir = neg(noz(new_vel));
    // let fric = fric_dir * normal_force * rb.cof;
    // rb.vel = new_vel + fric; //  + ref;

}

vec2 calc_new_vel(vec2 vel, normal, float32 mass, e, cof_s, cof_k) {
    float32 perp_speed = dot(vel, normal);
    vec2 perp = normal * perp_speed; // perpendicular velocity
    vec2 tang = vel - perp;          // tangential velocity

    vec2 new_perp = normal * -e * perp_speed;

    float32 tang_speed = length(tang);
    if tang_speed < 0.000001  return new_perp;

    float32 normal_impulse = mass * (1 + e) * abs(perp_speed);
    float32 tangental_impulse = mass * tang_speed;

    float32 static_friction  = cof_s * normal_impulse;
    float32 dynamic_friction = cof_k * normal_impulse;

    if tangental_impulse <= static_friction  return new_perp;

    vec2 new_tang = noz(tang) * max(0, tang_speed - dynamic_friction / mass);
    return new_tang + new_perp;
}

void draw_planet(Planet* planet) {

    if planet.grid.must_remesh {
        remesh(*planet.grid);
    }

    draw_circle(planet.tr.pos, planet.radius*2, make_vec(1,1,1, 0.1));

    Transform2D planet_tr = planet.tr;
    planet_tr.scale = (1.0 / random_texture.width);
    draw_texture(
        planet.grid.db,
        planet_tr,
        0,
        random_texture,
        false,
        vec2_zero, vec2_one,
        vec4_one, vec4_zero, vec4_zero);
}

Planet generate_planet(float32 radius, float32 dist) {
    Planet p = {};
    p.tr.scale = 1;
    p.radius = radius;
    p.orbit_dist = dist;
    p.orbit_duration = powf(p.orbit_dist, 3.0/2.0) * 0.1;
    p.grid = generate_planet_grid(*p);
    // p.orbit_phase = Pi * random(p.orbit_dist as int32);
    p.orbit_phase = 0;

    return p;
}

VoxelGrid generate_planet_grid(Planet* planet) {
    const radius2gridsize_ratio = 2.5;
    uint32 grid_size = (planet.radius * radius2gridsize_ratio) as uint32;
    VoxelGrid grid = createVoxelGrid(grid_size);

    float32 half = grid.res as float32 / 2;

    for uint32 x : 0 .. grid.res {
        for uint32 y : 0 .. grid.res {
            float32 xf = x as float32 - half;
            float32 yf = y as float32 - half;
            float32 len = sqrtf(xf*xf + yf*yf);
            const scale = 4.0;
            float32 offset = planet.orbit_dist;

            float32 f = 1.0 / len * scale;
            if len == 0.0  f = 0;

            let h = (gnoise(offset + xf * f, offset + yf * f) + 1.0) / 2.0;
            h *= planet.radius / 3.0;
            h = planet.radius - h;

            uint32 i = get_index(grid.res, x, y);
            grid.data[i] = clamp(h - len, 0, 1);

            // grid.data[i] = clamp(40 - len, 0, 1);

            // if len < 40 grid.data[i] = clamp(random(i as int32), 0, 1);
            // else grid.data[i] = 0;
        }
    }

    remesh(*grid);
    return grid;
}

void world_init() {
    camera.rot = 0;
    camera.scale = (400);

    entities = malloc(sizeof(Entity) * entities_capacity);
    planets = malloc(sizeof(Planet) * planets_count);

    float32 orbit_dist = 1000;
    for i : 0 .. planets_count {
        float32 radius = random_range(i as int32, 30, 100);
        orbit_dist += radius * 2;
        Planet p = generate_planet(radius, orbit_dist);
        orbit_dist += radius * 2;
        planets[i] = p;
    }

    vec2 spawn_pos = { planets[0].orbit_dist, planets[0].radius * 4/5.0 };
    player = spawn_guy(spawn_pos);
}

void update_player(Entity* en) {
    float32 dt = deltatime();

    if key('F')  en.rb.vel = {};

    en.tr.rot += input_axis('Q', 'E') * dt;

    float32 c = cosf(en.tr.rot);
    float32 s = sinf(en.tr.rot);
    mat2 m = { c, s, -s, c };
    vec2 up = m * vec2_unit_y;
    vec2 left = rot90deg(up);

    if Input.wasd.y > 0 {

        vec2 dir = up*9.8*1.3 - left*Input.wasd.x*5;
        en.rb.vel = en.rb.vel + dir*dt;


        Particle p = {};
        p.tr.pos = en.tr.pos;
        p.tr.scale = 0.3;
        p.tr.rot = random_range(-Pi, Pi);
        p.vel = en.rb.vel + neg(dir) + random_vec2(3);
        p.ang_vel = random_range(-Pi, Pi) * 10;
        spawn_particle(p);
    }


    if en.grounded {

        if key_pressed(GLFW_KEY_SPACE) {
            en.rb.vel = en.rb.vel + up*7;
        }

        let walk_dir = left * -Input.wasd.x;
        walk_dir = noz(walk_dir + en.normal * -dot(walk_dir, en.normal));

        draw_circle(en.tr.pos + walk_dir, 0.1, vec4_one);

        en.rb.vel = en.rb.vel + walk_dir*10 * dt;

        // TODO: try removing friction while walking (cof=0)
        // if sqlength(walk_dir) > 0.1 

    }

    if !key(GLFW_KEY_LEFT_CONTROL) {
        en.selected_item = ((en.selected_item + Input.mouse_scroll) as uint32) % Item_Count;
    }

    draw_text(vec2_zero, 0.05, item_name(en.selected_item), White);
    switch (en.selected_item) {
        case .Grenade: {
            let mouse_coord = getMouseWorldCoord();
            let diff = mouse_coord - en.tr.pos;
            let dir = noz(diff);
            vec2 vel = en.rb.vel + dir * 5 * clamp(length(diff)/2, 1, 3);
            vec2 start_pos = en.tr.pos + dir*en.radius;
            draw_trajectory(start_pos, vel, 1, Drag_Coff_Of_Sphere);

            if mouse_pressed(Left_Mouse) {
                let g = spawn_entity(db_circle);
                g.tex = white_texture;
                g.en_type = .Grenade;
                g.radius = 0.1;
                g.tr.scale = (g.radius);
                g.tr.pos = start_pos;
                g.rb.vel = vel;
                g.rb.cof_s = 1;
                g.rb.cof_k = 0.1;
            }

        } break;

        case .Drill: if en.planet modify_terrain(en.planet); break;

        case .Bazooka: {
            let mouse_coord = getMouseWorldCoord();
            let diff = mouse_coord - en.tr.pos;
            let dir = noz(diff);

            if en.planet {
                let grid = *en.planet.grid;

                vec2 o = get_local_coords(grid, en.planet.tr, en.tr.pos);
                vec2 d = rotate_vec(dir, en.planet.tr.rot);
                Voxel2D_Traversal_State state = start_traversal(o, d);
                while true {
                    traverse(*state);
                    let dist = dist(state);
                    if dist > 50 break;

                    Lineseg seg = {};
                    if get_lineseg(grid, en.planet.tr, state.coord.x, state.coord.y, *seg) {
                        vec2 pos = get_world_coords(grid, en.planet.tr, make_vec(state.coord) + seg.start);
                        draw_circle(pos, 0.07, make_vec(0,1,0,1));

                        pos = get_world_coords(grid, en.planet.tr, make_vec(state.coord) + seg.end);
                        draw_circle(pos, 0.07, make_vec(0,1,1,1));
                    }


                    vec2 pos = get_world_coords(grid, en.planet.tr, o + d*dist)
                    draw_circle(pos, 0.05, make_vec(0,0,1,0.7));

                    Transform2D tr = {
                        pos = get_world_coords(grid, en.planet.tr, make_vec(state.coord)),
                        scale = 1
                    };

                    draw_quad(tr, 0, make_vec(1,1,1,0.1));
                }
            }

        } break;
    }

    camera.pos = exp_decay(camera.pos, en.tr.pos, 10, dt);
    camera.rot = exp_decay(camera.rot, en.tr.rot, 10, dt);

    // draw_trajectory(en.tr.pos, en.rb.vel);
}

void world_update() {
    let dt = deltatime();

    float32 time = app.total_run_time;
    // time += 10000.0;
    time = 0;
    for i : 0 .. planets_count {
        Planet* planet = *planets[i];

        float32 angle = planet.orbit_phase + Tau * time / planet.orbit_duration;
        planet.tr.pos = {cosf(angle), sinf(angle)} * planet.orbit_dist;

        draw_planet(planet);
    }

    // draw_text({0, 0} as vec2, 0.1, make_string("Hello"), White);


    for 0 .. entities_count {
        let e = *entities[it];
        if is_inactive(e) continue;
        update_entity(e);
    }

    if player {
        update_player(player);
    } else {

    }

    {
        void quad(vec2 pos, float32 d, vec4 color) {
            Transform2D tr = {};
            tr.pos = pos + {planets[0].orbit_dist, planets[0].radius * 4/5.0} + {0, 2};
            tr.scale = 1;
            draw_quad(tr, d, color);
        }

        vec4 gray = make_vec(vec3_one*0.6, 1);
        vec4 dark = make_vec(vec3_one*0.1, 1);

        float32 dep = 0.01;

        quad(make_vec(0, 0), -dep, gray);
        quad(make_vec(1, 0), -dep, gray);
        quad(make_vec(2, 0), -dep, gray);
        quad(make_vec(3, 0), -dep, gray);
        quad(make_vec(0, 3), -dep, gray);
        quad(make_vec(1, 3), -dep, gray);
        quad(make_vec(2, 3), -dep, gray);
        quad(make_vec(3, 3), -dep, gray);

        quad(make_vec(0, 1), dep, dark);
        quad(make_vec(1, 1), dep, dark);
        quad(make_vec(2, 1), dep, dark);
        quad(make_vec(3, 1), dep, dark);
        quad(make_vec(0, 2), dep, dark);
        quad(make_vec(1, 2), dep, dark);
        quad(make_vec(2, 2), dep, dark);
        quad(make_vec(3, 2), dep, dark);
    }

    draw_clouds(*planets[0]);

    for 0 .. list_length(particles) {
        let p = *particles[it];

        p.tr.pos = p.tr.pos + p.vel*dt;
        p.tr.rot += p.ang_vel*dt;

        bool despawn = false;

        let planet = get_planet_of_influence(p.tr.pos);
        if planet {

            Intersection2D inter;
            if point_intersects(*planet.grid, planet.tr, p.tr.pos, *inter) {
                despawn = true;
            }

            vec2 diff = planet.tr.pos - p.tr.pos;
            vec2 down = noz(diff);
            p.vel = p.vel + down*9.8*dt;
        }

        draw_texture(
            db_quad,
            p.tr,
            p.depth,
            white_texture,
            false,
            vec2_zero, vec2_one,
            vec4_one, vec4_zero, vec4_zero);

        p.life_time += dt;

        if despawn {
            list_unordered_remove(particles, it);
            it--;
        }
    }

    for 0 .. entities_count {
        let e = *entities[it];
        if is_inactive(e) continue;

        draw_texture(
            e.db,
            e.tr,
            0,
            e.tex,
            false,
            vec2_zero, vec2_one,
            vec4_one, vec4_zero, vec4_zero);
    }


    cleanup_entity_pool();
}

void draw_clouds(Planet* p) {

    int32 seed = 0;
    vec4 color = {1,1,1, 1};

    uint32 num_clouds = 100;
    for 0 .. num_clouds {
        float32 angle = it / (num_clouds as float32) * Tau;

        let tex = texture_cloud; // white_texture;

        Transform2D tr = {};
        tr.scale = 20.0 / tex.width;
        tr.pos = p.tr.pos + {cosf(angle), sinf(angle)} * p.radius * 5/4.0 + random_vec2(seed++, 10);
        tr.rot = random_range(seed++, -Pi, Pi) + app.total_run_time * Tau * random_range(seed++, -0.005, 0.005);

        float32 depth = random_range(seed++, -0.1, 0.1);
        draw_texture(
            db_quad,
            tr,
            depth,
            tex,
            true,
            vec2_zero, vec2_one,
            color, vec4_zero, vec4_zero);
    }
}

vec2 getMouseWorldCoord() {
    float64 cx;
    float64 cy;
    glfwGetCursorPos(app.main_window, *cx, *cy);

    int32 w;
    int32 h;
    glfwGetFramebufferSize(app.main_window, *w, *h);

    float32 x = cx as float32 / w * 2 - 1;
    float32 y = -(cy as float32 / h * 2 - 1);

    x *= w as float32 / h;  // 16.0 / 9.0;

    // float32 c = cosf(camera.rot) * camera.zoom;
    // float32 s = sinf(camera.rot) * camera.zoom;
    // vec2 res;
    // res.x = c*x + s*y + camera.pos.x;
    // res.y = -s*x + c*y + camera.pos.y;
    let res = local2world(camera, x, y);
    return res;
}

DrawBuffers genCircle(int32 res, float32 radius) {
    uint32 vertsCount = res as uint32 + 1;
    vertex2D* verts = malloc(vertsCount * sizeof vertex2D);
    verts[0] = {
        pos = {},
        uv = {},
        color = White
    };

    for i : 1 .. res + 1 {
        float32 angle = i * Tau / res;
        verts[i].pos.x = cosf(angle) * radius;
        verts[i].pos.y = sinf(angle) * radius;

        verts[i].color = White;
    }

    uint32 indsCount = (res as uint32) * 3;
    uint32* inds = malloc(indsCount * sizeof uint32);
    uint32 i = 0;
    uint32 v = 1;
    while i < indsCount {
        inds[i] = 0;
        inds[i+1] = v++;
        inds[i+2] = v;
        i += 3;
    }

    inds[i - 1] = 1;

    let db = create_draw_buffers(sizeof vertex2D, vertex2D_attribs);
    update_buffers(*db, verts, vertsCount, inds, indsCount);
    free(verts);
    free(inds);

    bind_instance_buffer_to_vao(db.vao, draw2d_renderer.vbo_instances);

    return db;
}