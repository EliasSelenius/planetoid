
struct Entity {
    Transform2D tr;
    DrawBuffers db;
    vec2 vel;
}

struct Planet {
    VoxelGrid grid;
    Transform2D tr;

    float32 radius;
    float32 dist;
    float32 yearDuration;
    float32 orbitOffset;
}


const entitiesCapacity = 256;
int32 entitiesLength = 0;
Entity* entities;
Entity* player;


const planetsCount = 1;
Planet* planets;


Entity* appendEntity(DrawBuffers db) {
    if entitiesLength >= entitiesCapacity {
        print("Failed to append entity. Max limit reached.");
        return null;
    }

    let res = *entities[entitiesLength++];
    res.tr.pos = make_vec(0, 0);
    res.tr.scale = 1;
    res.tr.rot = 0;
    res.db = db;
    res.vel = make_vec(0, 0);
    return res;
}

void updateEntity(Entity* entity) {
    entity.tr.pos = add(entity.tr.pos, entity.vel);

    for i : 0 .. planetsCount {
        Planet* planet = *planets[i];

        vec2 diff = sub(planet.tr.pos, entity.tr.pos);
        vec2 normal = normalize(diff);

        float32 planetArea = Pi * planet.radius * planet.radius;
        float32 planetMass = planetArea; // assuming the same uniform mass-density on all planets.
        vec2 gravity = mul(normal, planetMass / sqlength(diff) * -0.000003);
        // entity.vel = add(entity.vel, gravity);

        check_collision(planet, entity);
    }

}

void check_collision(Planet* planet, Entity* entity) {
    Intersection2D intersection;
    if point_intersects(entity.tr.pos, *planet.grid, planet.tr, *intersection) {

        vec2 normal = intersection.surface_normal;
        vec2 correction = mul(normal, -intersection.distance);
        entity.tr.pos = add(entity.tr.pos, correction);

        // entity.vel = reflect(entity.vel, normal); // bounce
        entity.vel = add(entity.vel, mul(normal, -dot(entity.vel, normal))); // cancel velocity in direction of surface
    }
}

DrawBuffers genCircle(int32 res, float32 radius) {
    uint32 vertsCount = res as uint32 + 1;
    vertex2D* verts = malloc(vertsCount * sizeof vertex2D);
    verts[0] = {
        pos = {},
        uv = {},
        color = White
    };

    for i : 1 .. res + 1 {
        float32 angle = i * Tau / res;
        verts[i].pos.x = cosf(angle) * radius;
        verts[i].pos.y = sinf(angle) * radius;

        verts[i].color = White;
    }

    uint32 indsCount = (res as uint32) * 3;
    uint32* inds = malloc(indsCount * sizeof uint32);
    uint32 i = 0;
    uint32 v = 1;
    while i < indsCount {
        inds[i] = 0;
        inds[i+1] = v++;
        inds[i+2] = v;
        i += 3;
    }

    inds[i - 1] = 1;

    let db = create_draw_buffers(sizeof vertex2D, vertex2D_attribs);
    update_buffers(*db, verts, vertsCount, inds, indsCount);
    free(verts);
    free(inds);

    bind_instance_buffer_to_vao(db.vao, draw2d_renderer.vbo_instances);

    return db;
}

void draw_planet(Planet* planet) {

    { // voxels
        let mouseCoord = getMouseWorldCoord();

        // uniform_entity_pos(mouseCoord);
        // uniform_entity_scale(voxel_edit_radius);
        // draw_elements(voxelMesh_circle);

        Transform2D tr = { pos = mouseCoord, scale = voxel_edit_radius };
        draw_texture(
            voxelMesh_circle,
            tr,
            0,
            white_texture,
            false,
            vec2_zero, vec2_one,
            make_vec(1,1,1, 0.3), vec4_zero);


        Intersection2D intersection;
        if point_intersects(mouseCoord, *planet.grid, planet.tr, *intersection) {
            // print("Intersects ", intersection.distance, "\n");
        }

        if mouse(Left_Mouse) {
            add_circle(*planet.grid, planet.tr, voxel_edit_radius, mouseCoord.x, mouseCoord.y);
        } else if mouse(Right_Mouse) {
            remove_circle(*planet.grid, planet.tr, voxel_edit_radius, mouseCoord.x, mouseCoord.y);
        }
    }



    if planet.grid.must_remesh {
        remesh(*planet.grid);
        print(list_length(planet.grid.inds) as uint32, "\n");
    }

    draw_texture(
        planet.grid.db,
        planet.tr,
        0,
        white_texture,
        false,
        vec2_zero, vec2_one,
        vec4_one, vec4_zero);

    // apply_transform(planet.tr);
    // draw_elements(planet.grid.db);


    // Draw vertices as points
    // glBindVertexArray(planet.grid.db.vao);
    // glDrawArrays(GL_POINTS, 0, planet.grid.numVerts as int32);

    // draw outline
    // glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, voxelGrid.inds_outline_ebo);
    // glDrawElements(GL_LINES, list_length(voxelGrid.inds_outline), GL_UNSIGNED_INT, null);
    // glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, voxelGrid.db.ebo);
    // glBindVertexArray(0);
}

Planet generate_planet(float32 radius, float32 dist) {
    Planet p = {};
    p.tr.scale = 1;
    p.radius = radius;
    p.dist = dist;
    p.yearDuration = powf(dist, 3.0/2.0) * 0.0001;
    p.grid = generate_planet_grid(*p);
    // p.orbitOffset = Pi * random(dist as int32);
    p.orbitOffset = 0;

    return p;
}

VoxelGrid generate_planet_grid(Planet* planet) {
    const radius2gridsize_ratio = 10.0 / 4.0;
    uint32 grid_size = (planet.radius * radius2gridsize_ratio) as uint32;
    VoxelGrid grid = createVoxelGrid(grid_size);

    float32 half = grid.res as float32 / 2;

    for uint32 x : 0 .. grid.res {
        for uint32 y : 0 .. grid.res {
            float32 xf = x as float32 - half;
            float32 yf = y as float32 - half;
            float32 len = sqrtf(xf*xf + yf*yf);
            const scale = 4.0;
            float32 offset = planet.dist;

            float32 f = 1.0 / len * scale;
            if len == 0.0  f = 0;

            let h = (gnoise(offset + xf * f, offset + yf * f) + 1.0) / 2.0;
            h *= planet.radius / 3.0;
            h = planet.radius - h;

            uint32 i = get_index(grid.res, x, y);
            grid.data[i] = clamp(h - len, 0, 1);

            // grid.data[i] = clamp(40 - len, 0, 1);

            // if len < 40 grid.data[i] = clamp(random(i as int32), 0, 1);
            // else grid.data[i] = 0;
        }
    }

    remesh(*grid);
    return grid;
}

void update_player() {
    if key('F') { player.vel.x = 0.0; player.vel.y = 0.0; }

    float32 c = cosf(player.tr.rot);
    float32 s = sinf(player.tr.rot);
    vec2 dir = make_vec(dot(make_vec(c, s), Input.wasd), dot(make_vec(-s, c), Input.wasd));

    player.vel = add(player.vel, mul(dir, 0.01));


    player.tr.rot += input_axis('Q', 'E') * 0.05;

    // TODO: exponential decay?
    camera.pos = player.tr.pos;
    camera.rot = player.tr.rot;
}

void world_init() {
    camera.rot = 0;
    camera.scale = 400;

    entities = malloc(sizeof(Entity) * entitiesCapacity);
    planets = malloc(sizeof(Planet) * planetsCount);

    for i : 0 .. planetsCount {
        float32 r = 30.0 + random(i as int32) * 20;
        Planet p = generate_planet(r, 1000 + 100 * i);
        planets[i] = p;
    }

    player = appendEntity(genCircle(4, 0.1f));
    player.tr.pos = {1000, 0};
}

void world_update() {

    float32 time = glfwGetTime() as float32; // TODO: implement time, deltatime and timescale in grax
    // time += 10000.0;
    time = 0;
    for i : 0 .. planetsCount {
        Planet* planet = *planets[i];
        float32 t = Pi * 2.0;
        planet.tr.pos.x = cosf(planet.orbitOffset + t * time / planet.yearDuration) * planet.dist;
        planet.tr.pos.y = sinf(planet.orbitOffset + t * time / planet.yearDuration) * planet.dist;
        draw_planet(planet);
    }

    // draw_text({0, 0} as vec2, 0.1, make_string("Hello"), White);


    for i : 0 .. entitiesLength {
        let e = *entities[i];
        updateEntity(e);
    }

    update_player();

    for i : 0 .. entitiesLength {
        let e = *entities[i];

        draw_texture(
            e.db,
            e.tr,
            0,
            white_texture,
            false,
            vec2_zero, vec2_one,
            vec4_one, vec4_zero);
    }

}

vec2 getMouseWorldCoord() {
    float64 cx;
    float64 cy;
    glfwGetCursorPos(app.main_window, *cx, *cy);

    int32 w;
    int32 h;
    glfwGetFramebufferSize(app.main_window, *w, *h);

    float32 x = cx as float32 / w * 2 - 1;
    float32 y = -(cy as float32 / h * 2 - 1);

    x *= w as float32 / h;  // 16.0 / 9.0;

    // float32 c = cosf(camera.rot) * camera.zoom;
    // float32 s = sinf(camera.rot) * camera.zoom;
    // vec2 res;
    // res.x = c*x + s*y + camera.pos.x;
    // res.y = -s*x + c*y + camera.pos.y;
    let res = local2world(camera, x, y);
    return res;
}